1080: 
    the same with 15(newcoder)

1020:
    how to build binary tree from postorder and inorder

Hash:
    1078 1048 1050 1092 1084

Disjoint-set data structure:
    1107 1114 1118

Shortest path problem:
    1003 1018
    1030 1087 : Dijkstra + dfs + select one best path from many
    1111 : same, but too much code

Greedy algorithm:
    1033 1037 1067 1070

Tree: 
    1004: BFS
    1020: inorder,postorder ==> level order
    1053: DFS
    1115: build binary tree
    1135: Red-Black Tree, one point not AC
    1119: difficult, preorder, postorder ==> judge inorder is unique

Graph:
    1013: 图的遍历，统计强连通分量的个数
    1021: 两次dfs就可以找到所有目标节点，否则全部节点遍历超时

Dynamic programming:
    1007
    1040
    1045: Longest increasing subsequence (经典动态规划)
    1068: 01背包

Sorting:
    1012: not complete
    1016: not complete
    1028 1055

big number:
    1023
    1024 string

DFS:
    1103

Linked list:
    1032 1052 1074 1097


模拟测试：
v2:
    1100: 0 是 tret 四位字符，其他都是三位
    1101: 判断时，隐含信息注意一下
    1102: invert 的意思是把这颗树每一个节点的左右孩子互换
v3:
    1104: 一个点过不了
    1105: interesting
    1106: dfs

v4: 
    1108
    1109
    1110

v5 small exam:
    历时 2 小时 54 分，做完，终于把全部的点 ac 了
    1136: 只能手写加法，因为位数太大，最大 1000 位的数据相加
    1137: 题目说的 fin grade 是计算后的成绩，一开始我看成了输入的 final score
    1138: 题目说给后序第一个就好，所以就不建树了
    1139: 同性且互换好友的情况一开始没考虑到，还有就是题目复杂的时候时间要求反而不高，不用考虑太多时间优化。
